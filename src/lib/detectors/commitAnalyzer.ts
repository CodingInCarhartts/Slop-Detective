import type { SlopIndicator, GitHubCommit } from '../types'
import { boundedScale, ratio, stddev } from '../scoring'

const AI_PATTERNS = [
  /generated by/i,
  /auto-generated/i,
  /llm/i,
  /gpt/i,
  /chatgpt/i,
  /claude/i,
  /refactored by ai/i,
  /ai-generated/i,
  /copilot/i,
  /cursor/i,
  /prompt/i,
  /assisted-by:\s*(?:ai|copilot|chatgpt|claude|gpt)/i,
  /\bai assistant\b/i,
]

const BULK_PATTERNS = [
  /bulk/i,
  /mass/i,
  /scaffold/i,
  /boilerplate/i,
  /codegen/i,
  /generated by/i,
  /ai-generated/i,
  /refactor all/i,
  /apply suggestions/i,
]

const NARRATIVE_PATTERNS = [
  /restructure codebase/i,
  /modular architecture/i,
  /improve maintainability/i,
  /enhance(?:d|ment)?/i,
  /streamline(?:d|ment)?/i,
  /comprehensive/i,
  /production-ready/i,
  /robust/i,
  /best practices/i,
  /clean architecture/i,
]

export function analyzeCommitMessages(commits: GitHubCommit[]): {
  aiCommits: number
  bulkCommits: number
  totalCommits: number
  percentage: number
  aiSignal: number
  burstSignal: number
  bulkSignal: number
  indicators: SlopIndicator[]
} {
  const indicators: SlopIndicator[] = []
  let aiCommitCount = 0
  let bulkCommitCount = 0
  let templatedNarrativeCommits = 0
  let narrativePhraseHits = 0
  let conventionalStyleCommits = 0
  const openerCounts = new Map<string, number>()
  const commitGapsHours: number[] = []
  let previousDate: Date | null = null

  for (const commit of commits) {
    const rawMessage = commit.commit.message
    const message = rawMessage.toLowerCase()
    const firstLine = rawMessage.split('\n')[0] ?? rawMessage
    if (/^[a-z]+(?:\([^)]+\))?!?:\s.+/i.test(firstLine)) {
      conventionalStyleCommits++
    }

    const opener = firstLine.trim().toLowerCase().split(/\s+/).slice(0, 2).join(' ')
    if (opener) {
      openerCounts.set(opener, (openerCounts.get(opener) ?? 0) + 1)
    }

    const hasNarrativePhrase = NARRATIVE_PATTERNS.some((pattern) => pattern.test(message))
    if (hasNarrativePhrase) {
      narrativePhraseHits++
    }

    const hasStructuredBody = /\n\s*[-*]\s+/.test(rawMessage) || /\n\s*\d+\.\s+/.test(rawMessage)
    const longMessage = rawMessage.length > 120
    if ((longMessage || hasStructuredBody) && (hasNarrativePhrase || /^[a-z]+(?:\([^)]+\))?!?:\s/i.test(firstLine))) {
      templatedNarrativeCommits++
    }

    for (const pattern of AI_PATTERNS) {
      if (pattern.test(message)) {
        aiCommitCount++
        indicators.push({
          type: 'AI Commit',
          description: `AI-linked commit wording: "${compact(commit.commit.message)}"`,
          severity: 'medium',
        })
        break
      }
    }

    for (const pattern of BULK_PATTERNS) {
      if (pattern.test(message)) {
        bulkCommitCount++
        indicators.push({
          type: 'Bulk Commit Pattern',
          description: `Broad generation/refactor commit: "${compact(commit.commit.message)}"`,
          severity: 'medium',
        })
        break
      }
    }

    const commitDate = new Date(commit.commit.author.date)
    if (previousDate) {
      const gapHours = Math.abs(commitDate.getTime() - previousDate.getTime()) / 3600000
      commitGapsHours.push(gapHours)
    }
    previousDate = commitDate
  }

  const percentage = commits.length > 0 ? (aiCommitCount / commits.length) * 100 : 0
  const keywordSignal = boundedScale(percentage, 1, 30)
  const templatedSignal = boundedScale(ratio(templatedNarrativeCommits, commits.length), 0.08, 0.45)
  const narrativeSignal = boundedScale(ratio(narrativePhraseHits, commits.length), 0.1, 0.6)
  const conventionalSignal = boundedScale(ratio(conventionalStyleCommits, commits.length), 0.45, 0.95)
  const repeatedOpenerSignal = boundedScale(repeatedOpenerRatio(openerCounts, commits.length), 0.25, 0.7)
  const aiSignal = Math.min(
    (keywordSignal * 0.45) +
      (templatedSignal * 0.25) +
      (narrativeSignal * 0.15) +
      (conventionalSignal * 0.1) +
      (repeatedOpenerSignal * 0.05),
    1
  )
  const bulkSignal = boundedScale(ratio(bulkCommitCount, commits.length), 0.03, 0.35)

  const burstSignal = computeBurstSignal(commitGapsHours)
  if (burstSignal >= 0.5) {
    indicators.push({
      type: 'Bursty Commit Cadence',
      description: 'Many commits landed in short windows relative to history',
      severity: burstSignal > 0.75 ? 'high' : 'medium',
    })
  }
  if (templatedSignal >= 0.45 || narrativeSignal >= 0.5) {
    indicators.push({
      type: 'Templated Commit Narratives',
      description: 'Commit messages show repeated structured, assistant-like narrative phrasing',
      severity: templatedSignal >= 0.7 ? 'high' : 'medium',
    })
  }

  return {
    aiCommits: aiCommitCount,
    bulkCommits: bulkCommitCount,
    totalCommits: commits.length,
    percentage,
    aiSignal,
    burstSignal,
    bulkSignal,
    indicators,
  }
}

function computeBurstSignal(commitGapsHours: number[]): number {
  if (commitGapsHours.length === 0) return 0
  const tinyGaps = commitGapsHours.filter((gap) => gap <= 1).length
  const denseRatio = ratio(tinyGaps, commitGapsHours.length)
  const variability = stddev(commitGapsHours)
  const variabilitySignal = boundedScale(variability, 12, 96)
  return Math.min((denseRatio * 0.7) + (variabilitySignal * 0.3), 1)
}

function compact(value: string): string {
  const trimmed = value.trim().replace(/\s+/g, ' ')
  return trimmed.length > 80 ? `${trimmed.slice(0, 77)}...` : trimmed
}

function repeatedOpenerRatio(openerCounts: Map<string, number>, totalCommits: number): number {
  if (totalCommits <= 0 || openerCounts.size === 0) return 0
  let maxCount = 0
  for (const count of openerCounts.values()) {
    if (count > maxCount) maxCount = count
  }
  return maxCount / totalCommits
}
