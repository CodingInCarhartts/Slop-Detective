import type { SlopIndicator } from '../types'
import { boundedScale, ratio } from '../scoring'

const COMMENT_PATTERNS = [
  /(?:as an ai|ai assistant|generated by (?:chatgpt|claude|gpt)|copilot)/i,
  /(?:this function (?:handles|is responsible for)|the purpose of this)/i,
  /(?:step \d+:|first[, ]|next[, ]|finally[, ])/i,
  /(?:todo: (?:implement|improve) this later)/i,
  /(?:boilerplate|scaffold) (?:code|implementation)/i,
  /(?:here(?:'s| is) (?:the|an) updated)/i,
]

export function detectVerboseComments(content: string): {
  verboseBlocks: number
  matchedLines: number
  commentSignal: number
  indicators: SlopIndicator[]
} {
  const lines = content.split('\n')
  const indicators: SlopIndicator[] = []
  let verboseBlockCount = 0
  let matchedLines = 0

  for (let index = 0; index < lines.length; index++) {
    const line = lines[index]
    const trimmed = line.trim()
    const isComment = trimmed.startsWith('//') || trimmed.startsWith('/*') || trimmed.startsWith('*')
    if (!isComment) continue

    if (COMMENT_PATTERNS.some((pattern) => pattern.test(trimmed))) {
      matchedLines++
      const previous = lines[index - 1]?.trim() ?? ''
      if (!(previous.startsWith('//') || previous.startsWith('*') || previous.startsWith('/*'))) {
        verboseBlockCount++
      }
    }
  }

  if (matchedLines > 0) {
    indicators.push({
      type: 'Prompt-like Comment Pattern',
      description: `Detected ${matchedLines} AI-like comment lines across ${verboseBlockCount} block(s)`,
      severity: matchedLines >= 4 ? 'medium' : 'low',
    })
  }

  const commentDensity = ratio(matchedLines, Math.max(lines.length, 1))
  const commentSignal = boundedScale((commentDensity * 8) + boundedScale(verboseBlockCount, 1, 5), 0.1, 1.4)

  return {
    verboseBlocks: verboseBlockCount,
    matchedLines,
    commentSignal,
    indicators,
  }
}
